#!/usr/bin/python

#### claccordd.py
#### copyright 2015 (c) by mszegedy
####
#### This program is free software; you can redistribute it and/or modify it
#### under the terms of the GNU General Public License as published by the Free
#### Software Foundation; either version 2 of the License, or (at your option)
#### any later version.
####
#### This program is distributed in the hope that it will be useful, but
#### WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#### or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
#### for more details.
####
#### You should have received a copy of the GNU General Public License along
#### with this program; if not, write to the Free Software Foundation, Inc., 51
#### Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

"""claccordd daemon main file."""

### imports
import sys
import copy
import re
import evdev

### constants
KEYDOWN = 1 # evdev events use 1 for key being pressed down and
KEYUP = 0   # 0 for key being lifted back up
ECODES = evdev.ecodes.ecodes

### global variables that will get defined later when keys.conf is read
ONE_KEY_MODE = None  # True or False
M_MODE_KEYS = None   # a tuple of Key's
U_MODE_KEYS = None   # a tuple of Key's
L_MODE_KEYS = None   # a tuple of Key's
M_CHAR_KEYS = None   # a tuple of Key's
U_CHAR_KEYS = None   # a tuple of Key's
L_CHAR_KEYS = None   # a tuple of Key's
SHIFT_KEY = None     # a Key (typically LEFTSHIFT or RIGHTSHIFT)
CTRL_KEY = None      # a Key (typically LEFTCTRL or RIGHTCTRL)
ALT_KEY = None       # a Key (typically LEFTALT or RIGHTALT)
QUIT_KEY = None      # a Key
SPECIAL_CHARS = {}   # a dict; keys are str's, values are lists of Keypress'es

### functions
def scancodes_hash(codes):
    """
    Hashes an array of scancodes into a big number.
    """
    # We want to treat our list of keys as though they are unordered, so we
    # sort them. In practice, we may not actually have to do this (since the
    # way that the keys are put in is predictable), but better safe than sorry,
    # because otherwise this would be a hell of a bug to catch.
    codes.sort()
    # This converts an array of integers into an integer hash, based on the
    # algorithm provided by Mihai on the Theoretical Computer Science Stack
    # Exchange at the URL:
    # http://cstheory.stackexchange.com/questions/3390/is-there-a-hash-function-for-a-collection-i-e-multi-set-of-integers-that-has
    big_prime = 769 # big enough for our purposes; scancodes only go up to 768
    output = 0
    for index, code in enumerate(codes):
        output += code*big_prime**index
    return int(output)
def keys_hash(keys):
    """
    Hashes the array of keyboard Keys "keys" into a big number, based on their
    scancodes. (Describing this function out loud would be like an Abbot &
    Costello skit.
      "So, first you need the list of keys."
      "I thought this is the function that's supposed to *generate* the keys."
      "No, we need the keys for hashing."
      "Right, which is why we're using this hash function to generate keys."
      "No, the keys are generated by __init__."
      "So the keys *are* generated in it?")
    """
    return scancodes_hash([key.code for key in keys])

### classes
class Key:
    """
    Stores the name and code of a key.
    """
    def __init__(self, name):
        self.name = name
        try:
            self.code = ECODES['KEY_'+name]
        except KeyError:
            print("Badly defined key of name \"" + name +"\"!")
            class KeyDefinitionError(Exception):
                pass
            raise KeyDefinitionError()

class Keypress:
    """
    A single keypress, to be used in the output keys in LayoutCombo.
    """
    def __init__(self, key, key_action='PRESS'):
        self.key = key
        self.key_action = key_action # can be 'PRESS', 'DOWN', and 'UP'

class LayoutCombo:
    """A combo of keys that produces an output."""
    def __init__(self, mode_code, char_code, output_code,
                 mode_position='M', char_position='M'):
        ## instance variables
        self.mode_keys = []
        self.char_keys = []
        self.output_keypresses = []

        ## build mode keys
        self.set_mode(mode_code, mode_position)

        ## build char keys
        self.set_char(char_code, char_position)

        ## build output keys
        def get_category(output_code):
            """
            Gets the category so that __init__ can determine how to construct
            the output.
            """
            lowercase_letter_matcher = re.compile(r'^[a-z]$')
            lowercase_letter_matches = lowercase_letter_matcher.match(output_code)
            if lowercase_letter_matches != None:
                return 'ALNUM_LOWER'
            uppercase_letter_matcher = re.compile(r'^[A-Z]$')
            uppercase_letter_matches = uppercase_letter_matcher.match(output_code)
            if uppercase_letter_matches != None:
                return 'ALNUM_UPPER'
            special_code_matcher = re.compile(r'\+[\w_]+')
            special_code_matches = special_code_matcher.match(output_code)
            if special_code_matches != None:
                return 'SPECIAL'
            return 'UNICODE_SEQ'
        category = get_category(output_code)
        ## deal with normal uppercase and lowercase letters
        if category in ('ALNUM_LOWER', 'ALNUM_UPPER'):
            if category[-6:] == '_UPPER':
                self.output_keypresses.append(Keypress(SHIFT_KEY, "DOWN"))
            self.output_keypresses.append(Keypress(Key(output_code.upper())))
            if category[-6:] == '_UPPER':
                self.output_keypresses.append(Keypress(SHIFT_KEY, "UP"))
        ## deal with special characters, i.e. codes; codes must begin with a
        ## plus sign, and have the rest consist of uppercase letters and
        ## underscores
        elif category == 'SPECIAL':
            try:
                self.output_keypresses = list(SPECIAL_CHARS[output_code])
            except KeyError:
                print("Warning: probably an invalid special sequence code on "
                      "line " + str(line_count) + "!")
        ## deal with everything else; it will just type out the given Unicode
        ## characters
        elif category == 'UNICODE_SEQ':
            for char in output_code:
                # convert character to sequence, convert sequence to hex, lop
                # off the '0x' in front
                unicode_sequence = hex(ord(char))[2:]
                # hold down ctrl, shift, and u, and type the numbers of the seq
                self.output_keypresses.extend(
                    tuple((Keypress(CTRL_KEY, "DOWN"),
                           Keypress(SHIFT_KEY, "DOWN"),
                           Keypress(Key('U'), "DOWN"))) +\
                    tuple((Keypress(Key(digit.upper())) for digit in \
                           unicode_sequence)) +\
                    tuple((Keypress(Key('U'), "UP"),
                           Keypress(SHIFT_KEY, "UP"),
                           Keypress(CTRL_KEY, "UP"))))
    def set_mode(self, mode_code, mode_position=None):
        self.mode_keys = []
        if mode_position == None:
            mode_position = 'M'
        mode_keys_map = {}
        if mode_position == 'M':
            mode_keys_map = M_MODE_KEYS
        elif mode_position == 'U':
            mode_keys_map = U_MODE_KEYS
        elif mode_position == 'L':
            mode_keys_map = L_MODE_KEYS
        for place, sign in enumerate(mode_code):
            if sign == '*':
                key = mode_keys_map[place]
                # Is it really Easier to Ask Forgiveness than Permission?
                assert isinstance(key, Key)
                self.mode_keys.append(key)
    def set_char(self, char_code, char_position=None):
        self.char_keys = []
        if char_position == None:
            char_position = 'M'
        char_keys_map = {}
        if char_position == 'M':
            char_keys_map = M_CHAR_KEYS
        elif char_position == 'U':
            char_keys_map = U_CHAR_KEYS
        elif char_position == 'L':
            char_keys_map = L_CHAR_KEYS
        for place, sign in enumerate(char_code):
            if sign == '*':
                key = char_keys_map[place]
                # Is it really Easier to Ask Forgiveness than Permission?
                assert isinstance(key, Key)
                self.char_keys.append(key)
    def type_out(self, ui):
        """Types the character or character sequence represented by this
        combination."""
        EV_KEY = evdev.ecodes.EV_KEY
        for keypress in self.output_keypresses:
            if keypress.key_action == "PRESS":
                ui.write(EV_KEY, keypress.key.code, KEYDOWN)
                print(keypress.key.name+" DOWN")
                ui.write(EV_KEY, keypress.key.code, KEYUP)
                print(keypress.key.name+" UP")
            elif keypress.key_action == "DOWN":
                ui.write(EV_KEY, keypress.key.code, KEYDOWN)
                print(keypress.key.name+" DOWN")
            elif keypress.key_action == "UP":
                ui.write(EV_KEY, keypress.key.code, KEYUP)
                print(keypress.key.name+" UP")
        ui.syn()

class LayoutComboContainer:
    "A data structure that stores the layout combos."
    def __init__(self):
        self.data = {}
        # How data is stored:
        # dict, keys are mode-key hashes ->
        # dict, keys are char-key hashes ->
        # LayoutCombo
    def store(self, layout):
        mode_keys_hash = keys_hash(layout.mode_keys)
        char_keys_hash = keys_hash(layout.char_keys)
        try:
            self.data[mode_keys_hash]
        except KeyError:
            self.data[mode_keys_hash] = {}
        self.data[mode_keys_hash][char_keys_hash] = layout
    def retrieve(self, mode_keys, char_keys):
        # detect whether this is an array of scancodes or keys:
        if isinstance(char_keys[0], int):
            return self.data[scancodes_hash(mode_keys)]\
                            [scancodes_hash(char_keys)]
        elif isinstance(char_keys[0], Key):
            return self.data[keys_hash(mode_keys)][keys_hash(char_keys)]

### process the conf file
## matchers and necessary variables
# A review of the variables keys.conf sets:
#  [GeneralSettings]
#   ONE_KEY_MODE  True or False
#  [InputKeys]
#   M_MODE_KEYS   a list of Key's
#   U_MODE_KEYS   a list of Key's
#   L_MODE_KEYS   a list of Key's
#   M_CHAR_KEYS   a list of Key's
#   U_CHAR_KEYS   a list of Key's
#   L_CHAR_KEYS   a list of Key's
#   SHIFT_KEY     a Key (typically LEFTSHIFT or RIGHTSHIFT)
#   CTRL_KEY      a Key (typically LEFTCTRL or RIGHTCTRL)
#   ALT_KEY       a Key (typically LEFTALT or RIGHTALT)
#   QUIT_KEY      a Key
#  [SpecialChars]
#   SPECIAL_CHARS a dict; keys are str's, values are lists of Keypress'es

header_line_matcher = re.compile(r'^\[(\w+)\](#.*)?')
# match groups:
# 0: the whole line, if it's a valid header line (unused)
# 1: the header's name
# 2: the comment, if any (unused)

definition_line_matcher = \
    re.compile(r'^\s*(\S+)\s*=\s*([^#\n]*[^#\s])?\s*(#.*)?')
# match groups:
# 0: the whole line, if it's a valid definition line (unused)
# 1: the defined variable's name
# 2: the defined variable's value
# 3: the comment, if any (unused)

special_char_matcher = re.compile(r'^\+[\w_]+$')
# for use in identifying valid SpecialChars definitions

symbol_matcher = re.compile(r'^((PRESS|DOWN|UP)!)?(\w+)$')
# for use in parsing of SpecialChars definitions
# match groups:
# 0: the whole symbol, if it's a valid symbol (unused)
# 1: the symbol's prefix plus the exclamation point, if any (unused)
# 2: the symbol's prefix, if any
# 3: the symbol's key name

blank_line_matcher = re.compile(r'^\s*(#.*)?')
# match groups:
# 0: the whole line, if it's a valid blank line (unused)
# 1: the comment, if any (unused)

## start processing
try:
    conf_file = open('keys.conf', 'r')
except FileNotFoundError:
    print("Missing keys.conf!")
    sys.exit()
line_count = 0
header = None
for line in conf_file:
    line_count += 1
    header_line_matches = header_line_matcher.match(line)
    if header_line_matches != None: # it's a header
        new_header = header_line_matches.group(1)
        if new_header in ("GeneralSettings", "InputKeys", "SpecialChars"):
            header = new_header
        else:
            print("Invalid header in conf file! Error on line " +\
                  str(line_count))
        continue
    definition_line_matches = definition_line_matcher.match(line)
    if definition_line_matches != None: # it's a definition
        var_name = definition_line_matches.group(1)
        var_value = definition_line_matches.group(2)
        if header == "GeneralSettings":
            if var_name == "ONE_KEY_MODE":
                lowered = var_value.lower()
                if lowered == "true":
                    ONE_KEY_MODE = True
                elif lowered == "false":
                    ONE_KEY_MODE = False
                else:
                    print("Invalid definition in conf file! Error on line " +\
                          str(line_count))
            else:
                print("Invalid definition in conf file! Error on line " +\
                      str(line_count))
        elif header == "InputKeys":
            if var_name in ("M_MODE_KEYS", "U_MODE_KEYS", "L_MODE_KEYS",
                            "M_CHAR_KEYS", "U_CHAR_KEYS", "L_CHAR_KEYS"):
                new_keys = tuple((Key(name) for name in var_value.split()))
                if var_name == "M_MODE_KEYS":
                    M_MODE_KEYS = new_keys
                elif var_name == "U_MODE_KEYS":
                    U_MODE_KEYS = new_keys
                elif var_name == "L_MODE_KEYS":
                    L_MODE_KEYS = new_keys
                elif var_name == "M_CHAR_KEYS":
                    M_CHAR_KEYS = new_keys
                elif var_name == "U_CHAR_KEYS":
                    U_CHAR_KEYS = new_keys
                elif var_name == "L_CHAR_KEYS":
                    L_CHAR_KEYS = new_keys
                else:
                    print("Invalid definition in conf file! Error on line " +\
                          str(line_count))
            elif var_name == "SHIFT_KEY":
                SHIFT_KEY = Key(var_value)
                if var_value not in ("LEFTSHIFT", "RIGHTSHIFT"):
                    print("Warning: weird definition for shift key!")
            elif var_name == "CTRL_KEY":
                CTRL_KEY = Key(var_value)
                if var_value not in ("LEFTCTRL", "RIGHTCTRL"):
                    print("Warning: weird definition for ctrl key!")
            elif var_name == "ALT_KEY":
                ALT_KEY = Key(var_value)
                if var_value not in ("LEFTALT", "RIGHTALT"):
                    print("Warning: weird definition for alt key!")
            elif var_name == "QUIT_KEY":
                QUIT_KEY = Key(var_value)
            else:
                print("Invalid definition in conf file! Error on line " +\
                      str(line_count))
        elif header == "SpecialChars":
            if special_char_matcher.match(var_name) != None:
                def break_down_symbol(symbol):
                    """Make up the arguments for the map() call in the definition
                    of key_sequence."""
                    symbol_matches = symbol_matcher.match(symbol)
                    prefix = symbol_matches.group(2)
                    name = symbol_matches.group(3)
                    return (Key(name), "PRESSED" if prefix == None else prefix)
                key_sequence = tuple(
                    (Keypress(*args) for args in map(break_down_symbol,
                                                     var_value.split())))
                SPECIAL_CHARS[var_name] = key_sequence
            else:
                print("Invalid definition in conf file! Error on line " +\
                      str(line_count))
        continue
    blank_line_matches = blank_line_matcher.match(line)
    if blank_line_matches != None: # it's blank
        continue
    print("Invalid conf file! Error on line "+str(line_count))

### process the layout file
## matchers and necessary variables:
# absolutely disgusting:
mode_line_matcher =\
    re.compile(
        r'^([MUL])?([-*]{4,})'
        r'((:)|=\s*((S\+|C\+|M\+)*)([MUL])?([-*]{4,}))\s*(#.*)?')
# match groups:
# 0: the whole line, if it's a valid mode line (unused)
# 1: the position modifier of the mode keys, if any
# 2: the keys of the mode this is defining
# 3: the rest of the line that isn't a comment (unused)
# 4: the colon, if it's an original mode and not a copied one
# 5: the modifier keys, if it's a copied mode
# 6: the last modifier key, if it's a copied mode (unused)
# 7: the position of the mode it's copying from, if any
# 8: the keys of mode it's copying from, if any
# 9: the comment, if any (unused)

char_line_matcher = re.compile(r'([ MUL])([-* ]{6}) (.+);\s*(#.*)?')
# match groups:
# 0: the whole line, if it's a valid char line (unused)
# 1: the position modifier of the char keys, if any
# 2: the keys of the char that this is defining
# 3: the char that this is defining
# 4: the comment, if any (unused)

# (blank_line_matcher reused from previous file's processing)


try:
    layout_file = open('layout.txt', 'r')
except FileNotFoundError:
    print("Missing layout.txt!")
    sys.exit()
layout_combos = LayoutComboContainer()
line_count = 0
for line in layout_file:
    line_count += 1
    mode_line_matches = mode_line_matcher.match(line)
    if mode_line_matches != None: # it's a mode line
        mode = mode_line_matches.group(2)
        mode_position = 'M'
        if mode_line_matches.group(1) != None:
            mode_position = mode_line_matches.group(1)
            # print(("%(line_count)03d"+": "+mode_position+mode) %\
            #       {'line_count' : line_count})
        if mode_line_matches.group(4) != None:
            # print("    MODE LINE (U) @ "+str(line_count))
            pass
        else:
            # if this mode is a copy of another
            # print("    MODE LINE (C) @ "+str(line_count))
            # if line_count in (141, 142) + tuple(range(189, 205)):
            #     for x in range(0, 10):
            #         print("    GROUP "+str(x)+": "+\
            #               str(mode_line_matches.group(x)))
            modifier_keys = []
            if mode_line_matches.group(5) != None:
                for modifier in mode_line_matches.group(5).split('+')[:-1]:
                    if modifier == 'S':
                        modifier_keys.append(SHIFT_KEY)
                    elif modifier == 'C':
                        modifier_keys.append(CTRL_KEY)
                    elif modifier == 'M':
                        modifier_keys.append(ALT_KEY)
            # select every layout combo with the same mode keys as ours:
            original_mode = mode_line_matches.group(8)
            original_mode_position = mode_line_matches.group(7)
            dummy_layout_combo = LayoutCombo(original_mode,
                                             '',
                                             '',
                                             original_mode_position)
            for layout_combo in \
                layout_combos.data[
                    keys_hash(dummy_layout_combo.mode_keys)].values():
                layout_combo_copy = copy.deepcopy(layout_combo)
                layout_combo_copy.set_mode(mode, mode_position)
                layout_combo_copy.output_keypresses[0:0] = \
                    [Keypress(key, "DOWN") for key in modifier_keys]
                layout_combo_copy.output_keypresses.extend(
                    [Keypress(key, "UP") for key in modifier_keys[::-1]])
                layout_combos.store(layout_combo_copy)
        continue
    char_line_matches = char_line_matcher.match(line)
    if char_line_matches != None: # it's a char line
        char_position = 'M'
        if char_line_matches.group(1) != ' ':
            char_position = char_line_matches.group(1)
        layout_combo = LayoutCombo(mode,
                                   char_line_matches.group(2),
                                   char_line_matches.group(3),
                                   mode_position,
                                   char_position)
        layout_combos.store(layout_combo)
        # print("    LAYOUT STORED:")
        # print("        MODE KEYS: ", end="")
        # for key in layout_combo.mode_keys:
        #     print(key.name + " ", end="")
        # print()
        # print("        CHAR KEYS: ", end="")
        # for key in layout_combo.char_keys:
        #     print(key.name + " ", end="")
        # print()
        # print("        OUTPUT KEYPRESSES: ", end="")
        # for keypress in layout_combo.output_keypresses:
        #     print(keypress.key_action + "!" + keypress.key.name + " ", end="")
        # print()
        continue
    blank_line_matches = blank_line_matcher.match(line)
    if blank_line_matches != None: # it's blank
        continue
    print("Invalid layout file! Error on line "+str(line_count))
### start keyboarding
# for key in layout_combos.keys():
#     print(key+" : "+layout_combos[key].output_code+" : "+\
#           str([keypress.key_name for keypress in layout_combos[key].output_keys]))
ui = evdev.UInput()
kb = evdev.InputDevice('/dev/input/event0')
kb.grab()
mode_keys_active = set([])
char_keys_active = set([])
ALL_MODE_KEYS = set(M_MODE_KEYS + U_MODE_KEYS + L_MODE_KEYS)
ALL_CHAR_KEYS = set(M_CHAR_KEYS + U_CHAR_KEYS + L_CHAR_KEYS)
for event in kb.read_loop():
    if event.type == evdev.ecodes.EV_KEY:
        key_event = evdev.categorize(event)
        if key_event.keystate == KEYDOWN:
            if key_event.scancode == QUIT_KEY.code:
                ui.close()
                kb.ungrab()
                sys.exit()
            if key_event.scancode in [c.code for c in ALL_MODE_KEYS]:
                mode_keys_active.add(key_event.scancode)
            elif key_event.scancode in [c.code for c in ALL_CHAR_KEYS]:
                char_keys_active.add(key_event.scancode)
            else:
                ui.write_event(event)
                ui.syn()
        elif key_event.keystate == KEYUP:
            ## if it's a change in the mode keys:
            if key_event.scancode in [c.code for c in ALL_MODE_KEYS]:
                mode_keys_active.remove(key_event.scancode)
            elif key_event.scancode in [c.code for c in ALL_CHAR_KEYS]:
                ## figure out whether any char keys are being held down
                active_keys = kb.active_keys()
                char_keys_are_active = False
                for key in ALL_CHAR_KEYS:
                    if key.code in active_keys:
                        char_keys_are_active = True
                        break
                ## if no char keys are pressed, type the character
                if not char_keys_are_active:
                    try:
                        pressed_layout_combo = \
                            layout_combos.retrieve(list(mode_keys_active),
                                                   list(char_keys_active))
                        ## type the combo
                        pressed_layout_combo.type_out(ui)
                    except KeyError:
                        ui.write_event(event)
                        ui.syn()
                    # zero out the active char keys
                    char_keys_active = set([])
            else:
                ui.write_event(event)
                ui.syn()
        else:
            ui.write_event(event)
            ui.syn()
